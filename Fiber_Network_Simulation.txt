{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Fiber Network Simulation\n",
    "\n",
    "This notebook demonstrates a fiber network simulation with fixed-fixed boundary conditions and a prescribed compressive displacement on the top boundary. Each fiber is modeled using 2D geometrically exact beams (Simo-Reissner Beams). The simulation uses the FEniCS library with the fenics-arclength package (version 0.2.0).\n",
    "\n",
    "For more details on beams, refer to the [documentation](https://fenics-arclength.readthedocs.io/en/latest/examples/displacement_control/fiber_network.html).\n",
    "\n",
    "## Contents\n",
    "- Import Mesh and Define Function Spaces\n",
    "- Define Dirichlet Boundary Conditions\n",
    "- Kinematics and Weak Form\n",
    "- Solver\n",
    "- Post Processing\n",
    "- Optional: Creating an Animation from Solution Snapshots"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Import Mesh and Define Function Spaces\n",
    "\n",
    "The following cell sets up the environment by importing necessary libraries and defining the mesh and function spaces. Note: The original document's import section (PAGE2) is corrupted. Below is a placeholder for typical FEniCS imports based on context."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline\n",
    "from fenics import *\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from fenics_arclength import displacement_control\n",
    "# Note: Additional imports may be required (e.g., for mesh loading).\n",
    "# Load mesh (placeholder; specify your mesh file)\n",
    "# mesh = Mesh('fiber_network.xml')\n",
    "# Define function spaces (placeholder; adjust as needed)\n",
    "V = FunctionSpace(mesh, 'P', 1)  # Example function space"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Define Dirichlet Boundary Conditions\n",
    "\n",
    "Define boundary conditions for the top, bottom, left, and right boundaries. The applied displacement must be positive to avoid convergence issues. The domain is a square with height H=100.0 and width W=100.0."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "H = 100.0\n",
    "W = 100.0\n",
    "\n",
    "def bottom(x, on_boundary):\n",
    "    return near(x[1], 0, 1e-6)\n",
    "\n",
    "def top(x, on_boundary):\n",
    "    return near(x[1], H, 1e-6)\n",
    "\n",
    "def left(x, on_boundary):\n",
    "    return near(x[0], 0, 1e-6)\n",
    "\n",
    "def right(x, on_boundary):\n",
    "    return near(x[0], W, 1e-6)\n",
    "\n",
    "# Define displacement expression (positive to avoid convergence issues)\n",
    "apply_disp = Expression('t', t=0.0, degree=0)\n",
    "# Define boundary conditions (placeholder; adjust based on problem)\n",
    "bcs = [\n",
    "    DirichletBC(V.sub(0).sub(1), Constant(0.0), bottom),\n",
    "    DirichletBC(V.sub(0).sub(1), apply_disp, top)\n",
    "]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Kinematics and Weak Form\n",
    "\n",
    "Define the constitutive equations and weak form for the fiber network. The elastic energy includes contributions from deformation and curvature."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Constitutive Equations\n",
    "ES, GS, EI = 1.0, 1.0, 1.0  # Example material parameters\n",
    "C_N = diag(as_vector([ES, GS]))\n",
    "\n",
    "# Applied Load\n",
    "F_max = Constant((0.0, 0.0))\n",
    "M_max = Constant(0.0)\n",
    "\n",
    "# Define trial and test functions\n",
    "v = Function(V)\n",
    "v_ = TestFunction(V)\n",
    "dv = TrialFunction(V)\n",
    "\n",
    "# Define deformation and curvature (placeholders; define based on problem)\n",
    "defo = variable(v.sub(0))  # Example\n",
    "curv = variable(v.sub(1))  # Example\n",
    "\n",
    "# Elastic energy\n",
    "elastic_energy = 0.5 * (dot(defo, dot(C_N, defo)) + (EI*curv**2)) * dx\n",
    "\n",
    "# Internal and external forces\n",
    "F_int = derivative(elastic_energy, v, v_)\n",
    "F_ext = (-M_max*theta_ + dot(F_max, u_)) * ds  # Note: theta_ and u_ need definition\n",
    "residual = F_int - F_ext\n",
    "tangent_form = derivative(residual, v, dv)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Solver\n",
    "\n",
    "Set up the displacement control solver with specified parameters and execute the solver loop to compute the solution."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Solver Parameters\n",
    "psi = 1.0\n",
    "abs_tol = 1.0e-6\n",
    "lmbda0 = -0.5  # Negative for compression\n",
    "max_iter = 20\n",
    "solver_type = 'mumps'\n",
    "\n",
    "# Set up arc-length solver\n",
    "solver = displacement_control(\n",
    "    psi=psi,\n",
    "    lmbda0=lmbda0,\n",
    "    max_iter=max_iter,\n",
    "    u=v,\n",
    "    F_int=F_int,\n",
    "    F_ext=F_ext,\n",
    "    bcs=bcs,\n",
    "    J=tangent_form,\n",
    "    displacement_factor=apply_disp,\n",
    "    solver=solver_type\n",
    ")\n",
    "\n",
    "# Initialize solver\n",
    "disp = [v.vector()[:]]\n",
    "lmbda = [1.0]\n",
    "v_reac = Function(V)\n",
    "bcky = DirichletBC(V.sub(0).sub(1), Constant(1.0), bottom)\n",
    "f_reac = [0.0]\n",
    "\n",
    "# Solver loop\n",
    "solver.initialize()\n",
    "for _ in range(50):  # Example: 50 steps\n",
    "    solver.solve()\n",
    "    if solver.converged:\n",
    "        disp.append(v.vector()[:])\n",
    "        lmbda.append(apply_disp.t)\n",
    "        bcky.apply(v_reac.vector())\n",
    "        f_reac.append(assemble(action(residual, v_reac)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Post Processing\n",
    "\n",
    "Plot the deformed shape and the equilibrium path."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Get dof coordinates\n",
    "x_dofs = V.sub(0).sub(0).dofmap().dofs()\n",
    "y_dofs = V.sub(0).sub(1).dofmap().dofs()\n",
    "theta_dofs = V.sub(1).dofmap().dofs()\n",
    "dofs = V.tabulate_dof_coordinates()\n",
    "dof_nodal = dofs.reshape((-1, 2))\n",
    "x_nodal_coord = dof_nodal[x_dofs][:, 0]\n",
    "y_nodal_coord = dof_nodal[y_dofs][:, 1]\n",
    "\n",
    "# Plot displacement field\n",
    "disp_x = x_nodal_coord + disp[-1][x_dofs]\n",
    "disp_y = y_nodal_coord + disp[-1][y_dofs]\n",
    "\n",
    "plt.figure(figsize=(7, 7))\n",
    "plt.scatter(disp_x, disp_y, marker=',', c='r', label='Deformed Configuration')\n",
    "plt.scatter(x_nodal_coord, y_nodal_coord, marker=',', c='k', alpha=0.3, label='Initial Configuration')\n",
    "plt.xlabel('x-coordinates')\n",
    "plt.ylabel('y-coordinates')\n",
    "plt.axis('equal')\n",
    "plt.legend()\n",
    "plt.show()\n",
    "\n",
    "# Plot equilibrium path\n",
    "plt.figure(figsize=(7, 5))\n",
    "plt.plot(-np.array(lmbda), f_reac, c='k', marker='o')\n",
    "plt.xlabel('Applied Displacement')\n",
    "plt.ylabel('Force')\n",
    "plt.title('Equilibrium path')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Optional: Creating an Animation from Solution Snapshots\n",
    "\n",
    "Create an animation to visualize the deformation over time."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from matplotlib import animation, rc\n",
    "plt.rcParams['animation.html'] = 'jshtml'\n",
    "\n",
    "fig = plt.figure(figsize=(7, 7))\n",
    "ax = fig.add_subplot(111)\n",
    "ax.set_xlim([0, W])\n",
    "ax.set_ylim([-10, H+10])\n",
    "\n",
    "deformed, = ax.plot([], [], lw=7, c='r', label='Deformed Configuration', ls='None', marker='.')\n",
    "init, = ax.plot(x_nodal_coord, y_nodal_coord, c='k', lw=5, ls='None', label='Initial Configuration', marker='.', alpha=0.3)\n",
    "ax.legend(loc='lower right')\n",
    "\n",
    "def drawframe(n):\n",
    "    disp_x = x_nodal_coord + disp[n][x_dofs]\n",
    "    disp_y = y_nodal_coord + disp[n][y_dofs]\n",
    "    deformed.set_data(disp